@using Serenity
@inject Microsoft.AspNetCore.Antiforgery.IAntiforgery Antiforgery
@{
    ViewData["Title"] = "SaaS Settings";
    Layout = "~/Views/Shared/_Layout.cshtml";
    // Generate / store antiforgery tokens (cookie + request token) so we can send it via JS fetch
    var anti = Antiforgery.GetAndStoreTokens(Context);
}
<meta name="csrf-token" content="@anti.RequestToken" />
<div class="saaS-settings card card-body" style="max-width:600px;">
    <h3><i class="fa fa-cogs text-primary"></i> SaaS / Razorpay Settings</h3>
    <div class="alert alert-info small">
        Only update the secret if you are rotating / changing it. Leaving it blank keeps the existing stored secret.
    </div>
    <form id="saaSSettingsForm" onsubmit="return false;">
        <div class="form-group">
            <label for="rpKeyId">Razorpay Key Id</label>
            <input id="rpKeyId" name="KeyId" class="form-control" autocomplete="off" />
            <small class="form-text text-muted" id="currentKeyIdMask"></small>
        </div>
        <div class="form-group">
            <label for="rpKeySecret">Razorpay Key Secret</label>
            <input id="rpKeySecret" name="KeySecret" class="form-control" autocomplete="new-password" placeholder="(leave blank to keep existing)" />
            <small class="form-text text-muted" id="secretStatus"></small>
        </div>
        <button id="saveBtn" type="button" class="btn btn-primary"><i class="fa fa-save"></i> Save</button>
        <span id="saveResult" class="ml-2"></span>
    </form>
</div>
<script>
    (function(){
        const safeJson = async (resp) => {
            const text = await resp.text();
            if(!text) return {};
            try { return JSON.parse(text); } catch { return { _raw: text }; }
        };
        const csrf = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content');
        const defaultHeaders = {'Content-Type':'application/json'};
        if(csrf){
            // ASP.NET Core default header name
            defaultHeaders['RequestVerificationToken'] = csrf;
        }
        const retrieve = () => fetch('/Services/Administration/SaaSSettings/Retrieve', { headers: csrf ? { 'RequestVerificationToken': csrf } : undefined })
            .then(r => { if(!r.ok) throw new Error('HTTP '+r.status); return r.json(); });
        const save = (data) => fetch('/Services/Administration/SaaSSettings/Save', {method:'POST', headers: defaultHeaders, body: JSON.stringify(data)})
            .then(async r => { const body = await safeJson(r); return { ok: r.ok, body }; });
        const keyIdInput = document.getElementById('rpKeyId');
        const secretInput = document.getElementById('rpKeySecret');
        const maskLabel = document.getElementById('currentKeyIdMask');
        const secretStatus = document.getElementById('secretStatus');
        const saveBtn = document.getElementById('saveBtn');
        const saveResult = document.getElementById('saveResult');

        retrieve().then(d => {
            if(d){
                if(d.KeyId) keyIdInput.value = d.KeyId;
                if(d.KeyIdMasked) maskLabel.textContent = 'Masked: ' + d.KeyIdMasked;
                secretStatus.textContent = d.HasSecret ? 'A secret is already stored.' : 'No secret stored yet.';
            }
        });

        saveBtn.addEventListener('click', () => {
            saveResult.textContent = '';
            const payload = { KeyId: keyIdInput.value.trim(), KeySecret: secretInput.value.trim() };
            if(!payload.KeyId){
                saveResult.textContent = 'Key Id required';
                saveResult.className = 'text-danger';
                return;
            }
            if(!payload.KeySecret) delete payload.KeySecret; // don't send empty to avoid overwriting
            save(payload).then(res => {
                const r = res.body || {};
                if(res.ok && r.success){
                    saveResult.textContent = 'Saved';
                    saveResult.className = 'text-success';
                    if(payload.KeySecret){
                        secretStatus.textContent = 'A secret is already stored.';
                        secretInput.value='';
                    }
                } else {
                    let msg = r.error || r.detail || (r._raw ? ('Unexpected response: '+ r._raw) : 'Failed');
                    saveResult.textContent = msg;
                    saveResult.className = 'text-danger';
                }
            }).catch(e => {
                saveResult.textContent = 'Error: ' + e;
                saveResult.className = 'text-danger';
            });
        });
    })();
</script>
